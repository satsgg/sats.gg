// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "postgres"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"

  previewFeatures = ["fullTextSearch", "fullTextIndex", "interactiveTransactions"]
}

model User {
  id               String    @id @default(uuid())
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  lastLogin        DateTime?
  publicKey        String    @unique
  defaultZapAmount Int       @default(1000)

  streams Stream[]
}

model UserAuth {
  id            String   @id @default(uuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  challengeHash String   @unique
}

model Stream {
  id                   String           @id @default(uuid())
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt
  expiresAt            DateTime?
  userId               String
  user                 User             @relation(fields: [userId], references: [id])
  hlsUrl               String?
  rtmpUrl              String?
  streamKey            String
  lightningAddress     String?
  duration             Int
  viewerCount          Int              @default(0)
  viewerCountUpdatedAt DateTime         @default(now())
  // TODO: add nip 53 values or keep in localStorage?
  status               StreamStatus     @default(PENDING)
  variants             StreamVariant[]
  channelInvoices      ChannelInvoice[]
  streamInvoices       StreamInvoice[]
  // holdInvoicePayments  HoldInvoicePayment[]
}

// TODO: figure these out
// stream status vs creation status?
// StreamStatus + ChannelStatus?
enum StreamStatus {
  PENDING
  PROVISIONING
  PROVISIONING_FAILED
  READY
  LIVE
  ENDED
  // TERMINATING
  // TERMINATING_FAILED
  // TERMINATED
}

model StreamVariant {
  id            String          @id @default(uuid())
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  streamId      String
  stream        Stream          @relation(fields: [streamId], references: [id])
  price         Int
  height        Int
  width         Int
  framerate     Int
  StreamInvoice StreamInvoice[]
  // holdInvoicePayments HoldInvoicePayment[]
}

model ChannelInvoice {
  id            String        @id @default(uuid())
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  settledAt     DateTime?
  maxAgeSeconds Int
  description   String
  status        InvoiceStatus @default(OPEN)
  hash          String        @unique
  bolt11        String
  mSatsTarget   Int
  streamId      String
  stream        Stream        @relation(fields: [streamId], references: [id])
}

model StreamInvoice {
  id              String        @id @default(uuid())
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  settledAt       DateTime?
  maxAgeSeconds   Int
  description     String
  status          InvoiceStatus @default(OPEN)
  hash            String        @unique
  preimage        String?
  bolt11          String
  mSatsTarget     Int
  streamId        String
  stream          Stream        @relation(fields: [streamId], references: [id])
  streamVariantId String
  streamVariant   StreamVariant @relation(fields: [streamVariantId], references: [id])
  // holdInvoicePayments HoldInvoicePayment[] // multiple for potential retries?
}

// TODO: Use purchases as viewer count?

// TODO: streamer payments
// model HoldInvoicePayment {
//   id            String        @id @default(uuid())
//   createdAt     DateTime      @default(now())
//   updatedAt     DateTime      @updatedAt
//   settledAt     DateTime?
//   hash          String        @unique
//   bolt11        String
//   mSatsTarget   Int
//   streamId      String
//   stream        Stream        @relation(fields: [streamId], references: [id])
//   streamInvoiceId String
//   streamInvoice   StreamInvoice @relation(fields: [streamInvoiceId], references: [id])
//   variantId       String
//   variant         StreamVariant @relation(fields: [variantId], references: [id])
// }

enum InvoiceStatus {
  OPEN
  SETTLED
  CANCELED
  ACCEPTED
  //TODO: Add EXPIRED?
}
